from typing import Dict, List
from models import Option

def make(option: Option, timestamp: str) -> str:
    allowed_headers: List[str] = [h for h in option.allowedHeaders]
    header_overrides: Dict[str, str] = {h: v for h, v in option.headerOverrides.items()}
    blocked_domains: List[str] = list(option.blockedDomains)
    return f'''\
"""
Generated by mitm script generator at {timestamp}
Option: {option.title}
Description: {option.description}
"""
import re
from typing import Dict, List
from mitmproxy import http
ALLOWED_HEADERS: List[str] = {allowed_headers}
HEADER_OVERRIDES: Dict[str, str] = {header_overrides}
BLOCKED_DOMAINS: List[str] = {blocked_domains}
BLOCKED_PATTERNS: List[re.Pattern[str]] = {option.blockedDomainPatterns}
def request(flow: http.HTTPFlow) -> None:
    header_allowlist: set[str] = set(ALLOWED_HEADERS)
    for header in list(flow.request.headers.keys()):
        if 'all' not in header_allowlist and ('none' in header_allowlist or header not in header_allowlist):
            del flow.request.headers[header]
        if header in header_allowlist and header in HEADER_OVERRIDES:
            flow.request.headers[header] = HEADER_OVERRIDES[header]
    # Check if domain blocked
    if isBlockedDomain(flow.request.pretty_host):
        flow.response = http.Response.make(
            403,
            b"Blocked by mitmproxy: Domain is blocked",
            {{"Content-Type": "text/plain"}}
        )
        return
    # Block by URL pattern
    for pattern in BLOCKED_PATTERNS:
        if pattern.search(flow.request.pretty_url):
            flow.response = http.Response.make(
                403,
                b"Blocked by mitmproxy: URL pattern is blocked",
                {{"Content-Type": "text/plain"}}
            )
            return
def isBlockedDomain(domain: str) -> bool:
    return ('all' in BLOCKED_DOMAINS) or any(blocked_domain.lower() in domain.lower() for blocked_domain in BLOCKED_DOMAINS)
'''